import frappe
from frappe import _

def on_submit(doc, method):
	check_and_create_payment_entry(doc)

def validate(doc, method):
	if not doc.is_return and not doc.mode_of_payment:
		frappe.throw(_("Please set Mode of Payment."))

def on_cancel(doc, method):
	# Payment entries and Journal Entries get unlinked at this point in the original on_cancel.
	# cancel_and_delete_ritenuta_journal_entry(doc)
	cancel_and_delete_payment_entry(doc)

@frappe.whitelist()
def create_ritenuta_je_and_update_advances(doc):
	import json

	doc = json.loads(doc)
	doc = frappe._dict(doc)

	# Create a journal entry to show deducted Ritenuta as an advance.
	journal_entry = frappe.new_doc("Journal Entry")
	journal_entry.voucher_type = "Journal Entry"
	journal_entry.posting_date = doc.posting_date
	journal_entry.company = doc.company

	ritenuta_account = frappe.db.get_value("EFE Settings", "EFE Settings", "ritenuta_account")

	# Ritenuta amount is 20 % of the doc amount.
	amount = doc.total * 0.2

	# Create debit and credit entries to reflect Ritenuta as an advance.
	journal_entry.append('accounts', {
		"account": ritenuta_account,
		"debit_in_account_currency": amount
	})

	debtors_account = frappe.db.get_value("Account", {"account_name": "Debtors"}, "name")

	journal_entry.append('accounts', {
		"account": debtors_account,
		"party_type": "Customer",
		"party": doc.customer,
		"credit_in_account_currency": amount,
		"is_advance": "Yes",
	})
	journal_entry.save()
	journal_entry.submit()

	return journal_entry

# def cancel_and_delete_ritenuta_journal_entry(doc):
# 	# Get Journal Entry where:
# 	# 1. Party is the same as on the invoice.
# 	# 2. Posting date is the same as on the invoice.
# 	# 3. (Autogenerated) remark has the sales invoice reference.

# 	ritenuta_account = frappe.db.get_value("EFE Settings", "EFE Settings", "ritenuta_account")

# 	unlinked_ritenuta_jes = frappe.db.sql("""
# 			SELECT je.name
# 			FROM `tabJournal Entry` je
# 			INNER JOIN `tabJournal Entry Account` jea ON je.name = jea.parent
# 			WHERE je.posting_date = '{posting_date}'
# 			AND jea.account = '{ritenuta_account}'
# 			AND jea.against_account = {customer_account}
# 			AND jea.reference_type = null AND jea.reference_name = null;
# 		""".format(
# 			posting_date=doc.posting_date,
# 			invoice_name=doc.name,
# 			ritenuta_account=ritenuta_account.replace("'", "''")
# 		), as_dict=1)

# 	print("RITENUTA JE's", unlinked_ritenuta_jes)

# 	for ritenuta_je in unlinked_ritenuta_jes:
# 		je = frappe.get_doc("Journal Entry", ritenuta_je.get("name"))
# 		je.cancel()
# 		frappe.delete_doc("Journal Entry", ritenuta_je.get("name"))
# 		frappe.msgprint(_("Journal Entry '{0}' cancelled and deleted.".format(ritenuta_je.get("name"))))

def cancel_and_delete_payment_entry(doc):
	# Payment entries are auto-generated. Remarks will have a reference to the original Sales Invoice
	# consistently UNLESS THE REMARK ARE MODIFIED MANUALLY (unlikely).

	if not doc.is_return:
		pe_no = frappe.get_all("Payment Entry", filters={
			"posting_date": doc.posting_date,
			"party": doc.customer,
			"remarks":("LIKE", "%{0}%".format(doc.name))
		})

		if len(pe_no):
			pe_no = pe_no[0].get("name")
		else:
			return

		if frappe.db.get_value("Payment Entry", pe_no):
			payment_entry = frappe.get_doc("Payment Entry", pe_no)
			payment_entry.cancel()
			frappe.db.commit()
			frappe.delete_doc("Payment Entry", payment_entry.name)
			frappe.msgprint(_("Payment entry '{0}' cancelled and deleted.".format(pe_no)))

@frappe.whitelist()
def check_and_create_payment_entry(doc):
	if not doc.is_return:

		#create payment entry
		from erpnext.accounts.doctype.payment_entry.payment_entry import get_payment_entry
		pe = get_payment_entry(doc.doctype, doc.name)
		pe.mode_of_payment = doc.mode_of_payment
		pe.reference_no = "-"
		pe.reference_date = doc.posting_date or frappe.utils.getdate()
		pe.insert()
		pe.submit()

		frappe.msgprint("Payment entry created", alert=True)
